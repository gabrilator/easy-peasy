{"version":3,"file":"easy-peasy.umd.js","sources":["../src/context.js","../src/hooks.js","../src/constants.js","../src/helpers.js","../src/lib.js","../src/create-reducer.js","../src/persistence.js","../src/actions.js","../src/thunks.js","../src/extract-data-from-model.js","../src/listeners.js","../src/computed-properties.js","../src/create-store.js","../src/create-store-internals.js","../src/index.js","../src/provider.js","../src/create-component-store.js","../src/create-context-store.js","../src/create-transform.js"],"sourcesContent":["import { createContext } from 'react';\r\n\r\nconst StoreContext = createContext();\r\n\r\nexport default StoreContext;\r\n","import {\r\n  useContext,\r\n  useEffect,\r\n  useLayoutEffect,\r\n  useReducer,\r\n  useRef,\r\n  useState,\r\n} from 'react';\r\nimport EasyPeasyContext from './context';\r\n\r\n// React currently throws a warning when using useLayoutEffect on the server.\r\n// To get around it, we can conditionally useEffect on the server (no-op) and\r\n// useLayoutEffect in the browser. We need useLayoutEffect to ensure the store\r\n// subscription callback always has the selector from the latest render commit\r\n// available, otherwise a store update may happen between render and the effect,\r\n// which may cause missed updates; we also must ensure the store subscription\r\n// is created synchronously, otherwise a store update may occur before the\r\n// subscription is created and an inconsistent state may be observed\r\nconst useIsomorphicLayoutEffect =\r\n  typeof window !== 'undefined' ? useLayoutEffect : useEffect;\r\n\r\nexport function createStoreStateHook(Context) {\r\n  return function useStoreState(mapState) {\r\n    const store = useContext(Context);\r\n    const mapStateRef = useRef(mapState);\r\n    const stateRef = useRef();\r\n    const mountedRef = useRef(true);\r\n    const subscriptionMapStateError = useRef();\r\n\r\n    const [, forceRender] = useReducer(s => s + 1, 0);\r\n\r\n    if (\r\n      subscriptionMapStateError.current ||\r\n      mapStateRef.current !== mapState ||\r\n      stateRef.current === undefined\r\n    ) {\r\n      try {\r\n        stateRef.current = mapState(store.getState());\r\n      } catch (err) {\r\n        if (process.env.NODE_ENV === 'development') {\r\n          let errorMessage = `An error occurred trying to map state in a useStoreState hook: ${err.message}.`;\r\n          if (subscriptionMapStateError.current) {\r\n            errorMessage += `\\nThis error may be related to the following error:\\n${subscriptionMapStateError.current.stack}\\n\\nOriginal stack trace:`;\r\n          }\r\n          throw new Error(errorMessage);\r\n        }\r\n        throw subscriptionMapStateError.current || err;\r\n      }\r\n    }\r\n\r\n    useIsomorphicLayoutEffect(() => {\r\n      mapStateRef.current = mapState;\r\n      subscriptionMapStateError.current = undefined;\r\n    });\r\n\r\n    useIsomorphicLayoutEffect(() => {\r\n      const checkMapState = () => {\r\n        try {\r\n          const newState = mapStateRef.current(store.getState());\r\n          if (newState === stateRef.current) {\r\n            return;\r\n          }\r\n          stateRef.current = newState;\r\n        } catch (err) {\r\n          // see https://github.com/reduxjs/react-redux/issues/1179\r\n          // There is a possibility mapState will fail due to stale state or\r\n          // props, therefore we will just track the error and force our\r\n          // component to update. It should then receive the updated state\r\n          subscriptionMapStateError.current = err;\r\n        }\r\n        if (mountedRef.current) {\r\n          forceRender({});\r\n        }\r\n      };\r\n      const unsubscribe = store.subscribe(checkMapState);\r\n      checkMapState();\r\n      return () => {\r\n        mountedRef.current = false;\r\n        unsubscribe();\r\n      };\r\n    }, []);\r\n\r\n    return stateRef.current;\r\n  };\r\n}\r\n\r\nexport const useStoreState = createStoreStateHook(EasyPeasyContext);\r\n\r\nexport function createStoreActionsHook(Context) {\r\n  return function useStoreActions(mapActions) {\r\n    const store = useContext(Context);\r\n    return mapActions(store.getActions());\r\n  };\r\n}\r\n\r\nexport const useStoreActions = createStoreActionsHook(EasyPeasyContext);\r\n\r\nexport function createStoreDispatchHook(Context) {\r\n  return function useStoreDispatch() {\r\n    const store = useContext(Context);\r\n    return store.dispatch;\r\n  };\r\n}\r\n\r\nexport const useStoreDispatch = createStoreDispatchHook(EasyPeasyContext);\r\n\r\nexport function useStore() {\r\n  return useContext(EasyPeasyContext);\r\n}\r\n\r\nexport function createStoreRehydratedHook(Context) {\r\n  return function useStoreRehydrated() {\r\n    const store = useContext(Context);\r\n    const [rehydrated, setRehydrated] = useState(false);\r\n    useEffect(() => {\r\n      store.persist.resolveRehydration().then(() => setRehydrated(true));\r\n    }, []);\r\n    return rehydrated;\r\n  };\r\n}\r\n\r\nexport const useStoreRehydrated = createStoreRehydratedHook(EasyPeasyContext);\r\n\r\nexport function createTypedHooks() {\r\n  return {\r\n    useStoreActions,\r\n    useStoreDispatch,\r\n    useStoreState,\r\n    useStoreRehydrated,\r\n    useStore,\r\n  };\r\n}\r\n","export const actionSymbol = 'a';\r\nexport const actionOnSymbol = 'aO';\r\nexport const computedSymbol = 'c';\r\nexport const persistSymbol = 'p';\r\nexport const reducerSymbol = 'r';\r\nexport const thunkOnSymbol = 'tO';\r\nexport const thunkSymbol = 't';\r\n","import { isDraft, original } from 'immer-peasy';\r\nimport memoizerific from 'memoizerific';\r\nimport {\r\n  actionOnSymbol,\r\n  actionSymbol,\r\n  computedSymbol,\r\n  persistSymbol,\r\n  reducerSymbol,\r\n  thunkOnSymbol,\r\n  thunkSymbol,\r\n} from './constants';\r\n\r\nexport const debug = state => {\r\n  if (isDraft(state)) {\r\n    return original(state);\r\n  }\r\n  return state;\r\n};\r\n\r\nexport const memo = (fn, cacheSize) => memoizerific(cacheSize)(fn);\r\n\r\nexport const actionOn = (targetResolver, fn) => {\r\n  fn[actionOnSymbol] = {\r\n    targetResolver,\r\n  };\r\n  return fn;\r\n};\r\n\r\nexport const action = fn => {\r\n  fn[actionSymbol] = {};\r\n  return fn;\r\n};\r\n\r\nconst defaultStateResolvers = [state => state];\r\n\r\nexport const computed = (fnOrStateResolvers, fn) => {\r\n  if (typeof fn === 'function') {\r\n    fn[computedSymbol] = {\r\n      stateResolvers: fnOrStateResolvers,\r\n    };\r\n    return fn;\r\n  }\r\n  fnOrStateResolvers[computedSymbol] = {\r\n    stateResolvers: defaultStateResolvers,\r\n  };\r\n  return fnOrStateResolvers;\r\n};\r\n\r\nexport const persist = (model, config) => {\r\n  return {\r\n    ...model,\r\n    [persistSymbol]: config,\r\n  };\r\n};\r\n\r\nexport const thunkOn = (targetResolver, fn) => {\r\n  fn[thunkOnSymbol] = {\r\n    targetResolver,\r\n  };\r\n  return fn;\r\n};\r\n\r\nexport const thunk = fn => {\r\n  fn[thunkSymbol] = {};\r\n  return fn;\r\n};\r\n\r\nexport const reducer = fn => {\r\n  fn[reducerSymbol] = {};\r\n  return fn;\r\n};\r\n","import isPlainObject from 'is-plain-object';\r\nimport { createDraft, finishDraft, isDraft } from 'immer-peasy';\r\n\r\nexport const deepCloneStateWithoutComputed = source => {\r\n  const recursiveClone = current => {\r\n    const next = Object.keys(current).reduce((acc, key) => {\r\n      if (Object.getOwnPropertyDescriptor(current, key).get == null) {\r\n        acc[key] = current[key];\r\n      }\r\n      return acc;\r\n    }, {});\r\n    Object.keys(next).forEach(key => {\r\n      if (isPlainObject(next[key])) {\r\n        next[key] = recursiveClone(next[key]);\r\n      }\r\n    });\r\n    return next;\r\n  };\r\n  return recursiveClone(source);\r\n};\r\n\r\nexport const isPromise = x => {\r\n  return x != null && typeof x === 'object' && typeof x.then === 'function';\r\n};\r\n\r\nexport function get(path, target) {\r\n  return path.reduce((acc, cur) => {\r\n    return isPlainObject(acc) ? acc[cur] : undefined;\r\n  }, target);\r\n}\r\n\r\nexport function newify(currentPath, currentState, finalValue) {\r\n  if (currentPath.length === 0) {\r\n    return finalValue;\r\n  }\r\n  const newState = { ...currentState };\r\n  const key = currentPath[0];\r\n  if (currentPath.length === 1) {\r\n    newState[key] = finalValue;\r\n  } else {\r\n    newState[key] = newify(currentPath.slice(1), newState[key], finalValue);\r\n  }\r\n  return newState;\r\n}\r\n\r\nexport const set = (path, target, value) => {\r\n  if (path.length === 0) {\r\n    if (typeof value === 'object') {\r\n      Object.keys(target).forEach(key => {\r\n        delete target[key];\r\n      });\r\n      Object.keys(value).forEach(key => {\r\n        target[key] = value[key];\r\n      });\r\n    }\r\n    return;\r\n  }\r\n  path.reduce((acc, cur, idx) => {\r\n    if (idx + 1 === path.length) {\r\n      acc[cur] = value;\r\n    } else {\r\n      acc[cur] = acc[cur] || {};\r\n    }\r\n    return acc[cur];\r\n  }, target);\r\n};\r\n\r\nexport function createSimpleProduce(disableImmer = false) {\r\n  return function simpleProduce(path, state, fn) {\r\n    if (disableImmer) {\r\n      const current = get(path, state);\r\n      const next = fn(current);\r\n      if (current !== next) {\r\n        return newify(path, state, next);\r\n      }\r\n      return state;\r\n    }\r\n    if (path.length === 0) {\r\n      const draft = createDraft(state);\r\n      const result = fn(draft);\r\n      if (result) {\r\n        return isDraft(result) ? finishDraft(result) : result;\r\n      }\r\n      return finishDraft(draft);\r\n    }\r\n    const parentPath = path.slice(0, path.length - 1);\r\n    const draft = createDraft(state);\r\n    const parent = get(parentPath, state);\r\n    const current = get(path, draft);\r\n    const result = fn(current);\r\n\r\n    if (result) {\r\n      parent[path[path.length - 1]] = result;\r\n    }\r\n    return finishDraft(draft);\r\n  };\r\n}\r\n","import { createSimpleProduce, get } from './lib';\r\nimport { actionSymbol, actionOnSymbol } from './constants';\r\n\r\nexport default function createReducer(\r\n  disableImmer,\r\n  actionReducersDict,\r\n  customReducers,\r\n  computedProperties,\r\n) {\r\n  const simpleProduce = createSimpleProduce(disableImmer);\r\n\r\n  const runActionReducerAtPath = (state, action, actionReducer, path) => {\r\n    return simpleProduce(path, state, draft =>\r\n      actionReducer(draft, action.payload),\r\n    );\r\n  };\r\n\r\n  const reducerForActions = (state, action) => {\r\n    const actionReducer = actionReducersDict[action.type];\r\n    if (actionReducer) {\r\n      const actionMeta =\r\n        actionReducer[actionSymbol] || actionReducer[actionOnSymbol];\r\n      return runActionReducerAtPath(\r\n        state,\r\n        action,\r\n        actionReducer,\r\n        actionMeta.parent,\r\n      );\r\n    }\r\n    return state;\r\n  };\r\n\r\n  const reducerForCustomReducers = (state, action) => {\r\n    return customReducers.reduce((acc, { parentPath, key, reducer: red }) => {\r\n      return simpleProduce(parentPath, acc, draft => {\r\n        draft[key] = red(draft[key], action);\r\n        return draft;\r\n      });\r\n    }, state);\r\n  };\r\n\r\n  const rootReducer = (state, action) => {\r\n    const stateAfterActions = reducerForActions(state, action);\r\n    const next =\r\n      customReducers.length > 0\r\n        ? reducerForCustomReducers(stateAfterActions, action)\r\n        : stateAfterActions;\r\n    if (state !== next) {\r\n      computedProperties.forEach(({ parentPath, bindComputedProperty }) => {\r\n        bindComputedProperty(get(parentPath, next));\r\n      });\r\n    }\r\n    return next;\r\n  };\r\n\r\n  return rootReducer;\r\n}\r\n","import debounce from 'debounce';\r\nimport isPlainObject from 'is-plain-object';\r\nimport { deepCloneStateWithoutComputed, get, isPromise, set } from './lib';\r\n\r\nconst noopStorage = {\r\n  getItem: () => undefined,\r\n  setItem: () => undefined,\r\n  removeItem: () => undefined,\r\n};\r\n\r\nconst localStorage =\r\n  typeof window !== 'undefined' && typeof window.localStorage !== 'undefined'\r\n    ? window.localStorage\r\n    : noopStorage;\r\n\r\nconst sessionStorage =\r\n  typeof window !== 'undefined' && typeof window.sessionStorage !== 'undefined'\r\n    ? window.sessionStorage\r\n    : noopStorage;\r\n\r\nfunction createStorageWrapper(storage = sessionStorage, transformers = []) {\r\n  if (typeof storage === 'string') {\r\n    if (storage === 'localStorage') {\r\n      storage = localStorage;\r\n    } else if (storage === 'sessionStorage') {\r\n      storage = sessionStorage;\r\n    } else {\r\n      if (process.env.NODE_ENV === 'development') {\r\n        console.warn(\r\n          `Invalid storage provider specified for Easy Peasy persist: ${storage}\\nValid values include \"localStorage\", \"sessionStorage\" or a custom storage engine.`,\r\n        );\r\n      }\r\n      storage = noopStorage;\r\n    }\r\n  }\r\n\r\n  const outTransformers = transformers.reverse();\r\n\r\n  const serialize = (data, key) => {\r\n    const simpleKey = key.substr(key.indexOf('@') + 1);\r\n    const transformed = transformers.reduce((acc, cur) => {\r\n      return cur.in(acc, simpleKey);\r\n    }, data);\r\n    return storage === localStorage || storage === sessionStorage\r\n      ? JSON.stringify({ data: transformed })\r\n      : transformed;\r\n  };\r\n  const deserialize = (data, key) => {\r\n    const simpleKey = key.substr(key.indexOf('@') + 1);\r\n    const result =\r\n      storage === localStorage || storage === sessionStorage\r\n        ? JSON.parse(data).data\r\n        : data;\r\n    return outTransformers.reduce((acc, cur) => {\r\n      return cur.out(acc, simpleKey);\r\n    }, result);\r\n  };\r\n\r\n  const isAsync = isPromise(storage.getItem('_'));\r\n\r\n  return {\r\n    isAsync,\r\n    getItem: key => {\r\n      if (isAsync) {\r\n        return storage.getItem(key).then(wrapped => {\r\n          return wrapped != null ? deserialize(wrapped, key) : undefined;\r\n        });\r\n      }\r\n      const wrapped = storage.getItem(key);\r\n      return wrapped != null ? deserialize(wrapped, key) : undefined;\r\n    },\r\n    setItem: (key, data) => {\r\n      return storage.setItem(key, serialize(data, key));\r\n    },\r\n    removeItem: key => {\r\n      return storage.removeItem(key);\r\n    },\r\n  };\r\n}\r\n\r\nexport function extractPersistConfig(path, persistDefinition = {}) {\r\n  return {\r\n    path,\r\n    config: {\r\n      blacklist: persistDefinition.blacklist || [],\r\n      mergeStrategy: persistDefinition.mergeStrategy || 'merge',\r\n      storage: createStorageWrapper(\r\n        persistDefinition.storage,\r\n        persistDefinition.transformers,\r\n      ),\r\n      whitelist: persistDefinition.whitelist || [],\r\n    },\r\n  };\r\n}\r\n\r\nfunction resolvePersistTargets(target, whitelist, blacklist) {\r\n  let targets = Object.keys(target);\r\n  if (whitelist.length > 0) {\r\n    targets = targets.reduce((acc, cur) => {\r\n      if (whitelist.findIndex(x => x === cur) !== -1) {\r\n        return [...acc, cur];\r\n      }\r\n      return acc;\r\n    }, []);\r\n  }\r\n  if (blacklist.length > 0) {\r\n    targets = targets.reduce((acc, cur) => {\r\n      if (blacklist.findIndex(x => x === cur) !== -1) {\r\n        return acc;\r\n      }\r\n      return [...acc, cur];\r\n    }, []);\r\n  }\r\n  return targets;\r\n}\r\n\r\nexport function createPersistor(persistKey, references) {\r\n  return debounce(() => {\r\n    references.internals.persistenceConfig.forEach(({ path, config }) => {\r\n      const { storage, whitelist, blacklist } = config;\r\n      const state = references.getState();\r\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\r\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\r\n      targets.forEach(key => {\r\n        const targetPath = [...path, key];\r\n        storage.setItem(persistKey(targetPath), get(targetPath, state));\r\n      });\r\n    });\r\n  }, 1000);\r\n}\r\n\r\nexport function createPersistMiddleware(persistor, references) {\r\n  return () => next => action => {\r\n    const state = next(action);\r\n    if (\r\n      action &&\r\n      action.type !== '@action.ePRS' &&\r\n      references.internals.persistenceConfig.length > 0\r\n    ) {\r\n      persistor(state);\r\n    }\r\n    return state;\r\n  };\r\n}\r\n\r\nexport function createPersistenceClearer(persistKey, references) {\r\n  return () =>\r\n    new Promise((resolve, reject) => {\r\n      references.internals.persistenceConfig.forEach(({ path, config }) => {\r\n        const { storage, whitelist, blacklist } = config;\r\n        const persistRoot = get(path, references.getState());\r\n        const targets = resolvePersistTargets(\r\n          persistRoot,\r\n          whitelist,\r\n          blacklist,\r\n        );\r\n        if (targets.length > 0) {\r\n          Promise.all(\r\n            targets.map(key => {\r\n              const targetPath = [...path, key];\r\n              return storage.removeItem(persistKey(targetPath));\r\n            }),\r\n          ).then(() => resolve(), reject);\r\n        } else {\r\n          resolve();\r\n        }\r\n      });\r\n    });\r\n}\r\n\r\nexport function rehydrateStateFromPersistIfNeeded(\r\n  persistKey,\r\n  replaceState,\r\n  references,\r\n) {\r\n  // If we have any persist configs we will attemp to perform a state rehydration\r\n  let resolveRehydration = Promise.resolve();\r\n  if (references.internals.persistenceConfig.length > 0) {\r\n    references.internals.persistenceConfig.forEach(persistInstance => {\r\n      const { path, config } = persistInstance;\r\n      const { blacklist, mergeStrategy, storage, whitelist } = config;\r\n\r\n      const state = references.internals.defaultState;\r\n      const persistRoot = deepCloneStateWithoutComputed(get(path, state));\r\n      const targets = resolvePersistTargets(persistRoot, whitelist, blacklist);\r\n\r\n      const applyRehydrationStrategy = (originalState, rehydratedState) => {\r\n        if (mergeStrategy === 'overwrite') {\r\n          set(path, originalState, rehydratedState);\r\n        } else if (mergeStrategy === 'merge') {\r\n          const target = get(path, originalState);\r\n          Object.keys(rehydratedState).forEach(key => {\r\n            target[key] = rehydratedState[key];\r\n          });\r\n        } else if (mergeStrategy === 'mergeDeep') {\r\n          const target = get(path, originalState);\r\n          const setAt = (currentTarget, currentNext) => {\r\n            Object.keys(currentNext).forEach(key => {\r\n              const data = currentNext[key];\r\n              if (isPlainObject(data)) {\r\n                if (!isPlainObject(currentTarget[key])) {\r\n                  currentTarget[key] = {};\r\n                }\r\n                setAt(currentTarget[key], data);\r\n              } else {\r\n                currentTarget[key] = data;\r\n              }\r\n            });\r\n          };\r\n          setAt(target, rehydratedState);\r\n        }\r\n      };\r\n\r\n      if (storage.isAsync) {\r\n        const asyncStateResolvers = targets.reduce((acc, key) => {\r\n          const targetPath = [...path, key];\r\n          const dataPromise = storage.getItem(persistKey(targetPath));\r\n          if (isPromise(dataPromise)) {\r\n            acc.push({\r\n              key,\r\n              dataPromise,\r\n            });\r\n          }\r\n          return acc;\r\n        }, []);\r\n        if (asyncStateResolvers.length > 0) {\r\n          resolveRehydration = Promise.all(\r\n            asyncStateResolvers.map(x => x.dataPromise),\r\n          ).then(resolvedData => {\r\n            const next = resolvedData.reduce((acc, cur, idx) => {\r\n              const { key } = asyncStateResolvers[idx];\r\n              if (cur !== undefined) {\r\n                acc[key] = cur;\r\n              }\r\n              return acc;\r\n            }, {});\r\n            if (Object.keys(next).length === 0) {\r\n              return;\r\n            }\r\n            applyRehydrationStrategy(state, next);\r\n            replaceState(state);\r\n          });\r\n        }\r\n      } else {\r\n        const next = targets.reduce((acc, key) => {\r\n          const targetPath = [...path, key];\r\n          const data = storage.getItem(persistKey(targetPath));\r\n          if (data !== undefined) {\r\n            acc[key] = data;\r\n          }\r\n          return acc;\r\n        }, {});\r\n        applyRehydrationStrategy(state, next);\r\n        replaceState(state);\r\n      }\r\n    });\r\n  }\r\n  return resolveRehydration;\r\n}\r\n","import { actionSymbol, actionOnSymbol } from './constants';\r\n\r\nexport function createActionCreator(actionDefinition, meta, references) {\r\n  const prefix = actionDefinition[actionSymbol] ? '@action' : '@actionOn';\r\n  const type = `${prefix}.${meta.path.join('.')}`;\r\n  const actionMeta =\r\n    actionDefinition[actionSymbol] || actionDefinition[actionOnSymbol];\r\n  actionMeta.actionName = meta.key;\r\n  actionMeta.type = type;\r\n  actionMeta.parent = meta.parent;\r\n  actionMeta.path = meta.path;\r\n\r\n  const actionCreator = payload => {\r\n    const action = {\r\n      type,\r\n      payload,\r\n    };\r\n    if (actionDefinition[actionOnSymbol] && actionMeta.resolvedTargets) {\r\n      payload.resolvedTargets = [...actionMeta.resolvedTargets];\r\n    }\r\n    const result = references.dispatch(action);\r\n    return result;\r\n  };\r\n  actionCreator.type = type;\r\n\r\n  return actionCreator;\r\n}\r\n","import { thunkSymbol, thunkOnSymbol } from './constants';\r\nimport { get, isPromise } from './lib';\r\n\r\nexport function createThunkHandler(\r\n  thunkDefinition,\r\n  meta,\r\n  references,\r\n  injections,\r\n  actionCreators,\r\n) {\r\n  const thunkMeta =\r\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\r\n\r\n  return payload => {\r\n    const helpers = {\r\n      dispatch: references.dispatch,\r\n      getState: () => get(meta.parent, references.getState()),\r\n      getStoreActions: () => actionCreators,\r\n      getStoreState: references.getState,\r\n      injections,\r\n      meta,\r\n    };\r\n    if (thunkDefinition[thunkOnSymbol] && thunkMeta.resolvedTargets) {\r\n      payload.resolvedTargets = [...thunkMeta.resolvedTargets];\r\n    }\r\n    return thunkDefinition(get(meta.parent, actionCreators), payload, helpers);\r\n  };\r\n}\r\n\r\nexport function createThunkActionsCreator(\r\n  thunkDefinition,\r\n  meta,\r\n  references,\r\n  thunkHandler,\r\n) {\r\n  const prefix = thunkDefinition[thunkSymbol] ? '@thunk' : '@thunkOn';\r\n  const type = `${prefix}.${meta.path.join('.')}`;\r\n  const startType = `${type}(start)`;\r\n  const successType = `${type}(success)`;\r\n  const failType = `${type}(fail)`;\r\n\r\n  const thunkMeta =\r\n    thunkDefinition[thunkSymbol] || thunkDefinition[thunkOnSymbol];\r\n  thunkMeta.type = type;\r\n  thunkMeta.actionName = meta.key;\r\n  thunkMeta.parent = meta.parent;\r\n  thunkMeta.path = meta.path;\r\n\r\n  const actionCreator = payload => {\r\n    const dispatchError = err => {\r\n      references.dispatch({\r\n        type: failType,\r\n        payload,\r\n        error: err,\r\n      });\r\n      references.dispatch({\r\n        type,\r\n        payload,\r\n        error: err,\r\n      });\r\n    };\r\n    const dispatchSuccess = result => {\r\n      references.dispatch({\r\n        type: successType,\r\n        payload,\r\n        result,\r\n      });\r\n      references.dispatch({\r\n        type,\r\n        payload,\r\n        result,\r\n      });\r\n    };\r\n\r\n    references.dispatch({\r\n      type: startType,\r\n      payload,\r\n    });\r\n    try {\r\n      const result = references.dispatch(() => thunkHandler(payload));\r\n      if (isPromise(result)) {\r\n        return result\r\n          .then(resolved => {\r\n            dispatchSuccess(resolved);\r\n            return resolved;\r\n          })\r\n          .catch(err => {\r\n            dispatchError(err);\r\n            throw err;\r\n          });\r\n      }\r\n      dispatchSuccess(result);\r\n      return result;\r\n    } catch (err) {\r\n      dispatchError(err);\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  actionCreator.type = type;\r\n  actionCreator.startType = startType;\r\n  actionCreator.successType = successType;\r\n  actionCreator.failType = failType;\r\n\r\n  return actionCreator;\r\n}\r\n","import isPlainObject from 'is-plain-object';\r\nimport {\r\n  actionOnSymbol,\r\n  actionSymbol,\r\n  computedSymbol,\r\n  persistSymbol,\r\n  reducerSymbol,\r\n  thunkOnSymbol,\r\n  thunkSymbol,\r\n} from './constants';\r\nimport { get, set } from './lib';\r\nimport { extractPersistConfig } from './persistence';\r\nimport { createActionCreator } from './actions';\r\nimport { createThunkHandler, createThunkActionsCreator } from './thunks';\r\nimport { bindListenerDefinitions } from './listeners';\r\nimport { createComputedPropertyBinder } from './computed-properties';\r\n\r\nexport default function extractDataFromModel(\r\n  model,\r\n  initialState,\r\n  injections,\r\n  references,\r\n) {\r\n  const defaultState = initialState;\r\n  const actionCreatorDict = {};\r\n  const actionCreators = {};\r\n  const actionReducersDict = {};\r\n  const actionThunks = {};\r\n  const computedProperties = [];\r\n  const customReducers = [];\r\n  const listenerActionCreators = {};\r\n  const listenerActionMap = {};\r\n  const listenerDefinitions = [];\r\n  const persistenceConfig = [];\r\n  const computedState = {\r\n    isInReducer: false,\r\n    currentState: defaultState,\r\n  };\r\n\r\n  const recursiveExtractFromModel = (current, parentPath) =>\r\n    Object.keys(current).forEach(key => {\r\n      const value = current[key];\r\n      const path = [...parentPath, key];\r\n      const meta = {\r\n        parent: parentPath,\r\n        path,\r\n        key,\r\n      };\r\n      const handleValueAsState = () => {\r\n        const initialParentRef = get(parentPath, initialState);\r\n        if (initialParentRef && key in initialParentRef) {\r\n          set(path, defaultState, initialParentRef[key]);\r\n        } else {\r\n          set(path, defaultState, value);\r\n        }\r\n      };\r\n\r\n      if (key === persistSymbol) {\r\n        persistenceConfig.push(extractPersistConfig(parentPath, value));\r\n        return;\r\n      }\r\n\r\n      if (typeof value === 'function') {\r\n        if (value[actionSymbol] || value[actionOnSymbol]) {\r\n          const actionReducer = value;\r\n          const actionCreator = createActionCreator(value, meta, references);\r\n          actionCreatorDict[actionCreator.type] = actionCreator;\r\n          actionReducersDict[actionCreator.type] = actionReducer;\r\n          if (meta.key !== 'ePRS') {\r\n            if (value[actionOnSymbol]) {\r\n              listenerDefinitions.push(value);\r\n              set(path, listenerActionCreators, actionCreator);\r\n            } else {\r\n              set(path, actionCreators, actionCreator);\r\n            }\r\n          }\r\n        } else if (value[thunkSymbol] || value[thunkOnSymbol]) {\r\n          const thunkHandler = createThunkHandler(\r\n            value,\r\n            meta,\r\n            references,\r\n            injections,\r\n            actionCreators,\r\n          );\r\n          const actionCreator = createThunkActionsCreator(\r\n            value,\r\n            meta,\r\n            references,\r\n            thunkHandler,\r\n          );\r\n          set(path, actionThunks, thunkHandler);\r\n          actionCreatorDict[actionCreator.type] = actionCreator;\r\n          if (value[thunkOnSymbol]) {\r\n            listenerDefinitions.push(value);\r\n            set(path, listenerActionCreators, actionCreator);\r\n          } else {\r\n            set(path, actionCreators, actionCreator);\r\n          }\r\n        } else if (value[computedSymbol]) {\r\n          const parent = get(parentPath, defaultState);\r\n          const bindComputedProperty = createComputedPropertyBinder(\r\n            parentPath,\r\n            key,\r\n            value,\r\n            computedState,\r\n            references,\r\n          );\r\n          bindComputedProperty(parent);\r\n          computedProperties.push({ key, parentPath, bindComputedProperty });\r\n        } else if (value[reducerSymbol]) {\r\n          customReducers.push({ key, parentPath, reducer: value });\r\n        } else {\r\n          handleValueAsState();\r\n        }\r\n      } else if (isPlainObject(value)) {\r\n        const existing = get(path, defaultState);\r\n        if (existing == null) {\r\n          set(path, defaultState, {});\r\n        }\r\n        recursiveExtractFromModel(value, path);\r\n      } else {\r\n        handleValueAsState();\r\n      }\r\n    });\r\n\r\n  recursiveExtractFromModel(model, []);\r\n\r\n  bindListenerDefinitions(\r\n    listenerDefinitions,\r\n    actionCreators,\r\n    actionCreatorDict,\r\n    listenerActionMap,\r\n  );\r\n\r\n  return {\r\n    actionCreatorDict,\r\n    actionCreators,\r\n    actionReducersDict,\r\n    computedProperties,\r\n    customReducers,\r\n    computedState,\r\n    defaultState,\r\n    listenerActionCreators,\r\n    listenerActionMap,\r\n    persistenceConfig,\r\n  };\r\n}\r\n","import { actionOnSymbol, thunkOnSymbol } from './constants';\r\nimport { get } from './lib';\r\n\r\nexport function createListenerMiddleware(references) {\r\n  return () => next => action => {\r\n    const result = next(action);\r\n    if (\r\n      action &&\r\n      references.internals.listenerActionMap[action.type] &&\r\n      references.internals.listenerActionMap[action.type].length > 0\r\n    ) {\r\n      const sourceAction = references.internals.actionCreatorDict[action.type];\r\n      references.internals.listenerActionMap[action.type].forEach(\r\n        actionCreator => {\r\n          actionCreator({\r\n            type: sourceAction ? sourceAction.type : action.type,\r\n            payload: action.payload,\r\n            error: action.error,\r\n            result: action.result,\r\n          });\r\n        },\r\n      );\r\n    }\r\n    return result;\r\n  };\r\n}\r\n\r\nexport function bindListenerDefinitions(\r\n  listenerDefinitions,\r\n  actionCreators,\r\n  actionCreatorDict,\r\n  listenerActionMap,\r\n) {\r\n  listenerDefinitions.forEach(listenerActionOrThunk => {\r\n    const listenerMeta =\r\n      listenerActionOrThunk[actionOnSymbol] ||\r\n      listenerActionOrThunk[thunkOnSymbol];\r\n\r\n    const targets = listenerMeta.targetResolver(\r\n      get(listenerMeta.parent, actionCreators),\r\n      actionCreators,\r\n    );\r\n    const targetTypes = (Array.isArray(targets) ? targets : [targets]).reduce(\r\n      (acc, target) => {\r\n        if (\r\n          typeof target === 'function' &&\r\n          target.type &&\r\n          actionCreatorDict[target.type]\r\n        ) {\r\n          acc.push(target.type);\r\n        } else if (typeof target === 'string') {\r\n          acc.push(target);\r\n        }\r\n        return acc;\r\n      },\r\n      [],\r\n    );\r\n\r\n    listenerMeta.resolvedTargets = targetTypes;\r\n\r\n    targetTypes.forEach(targetType => {\r\n      const listenerReg = listenerActionMap[targetType] || [];\r\n      listenerReg.push(actionCreatorDict[listenerMeta.type]);\r\n      listenerActionMap[targetType] = listenerReg;\r\n    });\r\n  });\r\n}\r\n","import memoizerific from 'memoizerific';\r\nimport { get } from './lib';\r\nimport { computedSymbol } from './constants';\r\n\r\nexport function createComputedPropertyBinder(\r\n  parentPath,\r\n  key,\r\n  definition,\r\n  computedState,\r\n  references,\r\n) {\r\n  const computedMeta = definition[computedSymbol];\r\n  const memoisedResultFn = memoizerific(1)(definition);\r\n  return function createComputedProperty(o) {\r\n    Object.defineProperty(o, key, {\r\n      configurable: true,\r\n      enumerable: true,\r\n      get: () => {\r\n        let storeState;\r\n        if (computedState.isInReducer) {\r\n          storeState = computedState.currentState;\r\n        } else if (references.getState == null) {\r\n          return undefined;\r\n        } else {\r\n          try {\r\n            storeState = references.getState();\r\n          } catch (err) {\r\n            if (process.env.NODE_ENV === 'development') {\r\n              console.warn('Invalid access attempt to a computed property');\r\n            }\r\n            return undefined;\r\n          }\r\n        }\r\n        const state = get(parentPath, storeState);\r\n        const inputs = computedMeta.stateResolvers.map(resolver =>\r\n          resolver(state, storeState),\r\n        );\r\n        return memoisedResultFn(...inputs);\r\n      },\r\n    });\r\n  };\r\n}\r\n\r\nexport function createComputedPropertiesMiddleware(references) {\r\n  return store => next => action => {\r\n    references.internals.computedState.currentState = store.getState();\r\n    references.internals.computedState.isInReducer = true;\r\n    return next(action);\r\n  };\r\n}\r\n","import {\r\n  applyMiddleware,\r\n  compose as reduxCompose,\r\n  createStore as reduxCreateStore,\r\n} from 'redux';\r\nimport reduxThunk from 'redux-thunk';\r\nimport * as helpers from './helpers';\r\nimport createStoreInternals from './create-store-internals';\r\nimport {\r\n  createPersistor,\r\n  createPersistMiddleware,\r\n  createPersistenceClearer,\r\n  rehydrateStateFromPersistIfNeeded,\r\n} from './persistence';\r\nimport { createComputedPropertiesMiddleware } from './computed-properties';\r\nimport { createListenerMiddleware } from './listeners';\r\nimport { deepCloneStateWithoutComputed } from './lib';\r\n\r\nexport default function createStore(model, options = {}) {\r\n  const modelClone = deepCloneStateWithoutComputed(model);\r\n  const {\r\n    compose,\r\n    devTools = true,\r\n    disableImmer = false,\r\n    enhancers = [],\r\n    initialState = {},\r\n    injections,\r\n    middleware = [],\r\n    mockActions = false,\r\n    name: storeName = `EasyPeasyStore`,\r\n    reducerEnhancer = rootReducer => rootReducer,\r\n  } = options;\r\n\r\n  const bindReplaceState = modelDef => {\r\n    return {\r\n      ...modelDef,\r\n      ePRS: helpers.action((_, payload) => payload),\r\n    };\r\n  };\r\n\r\n  const references = {};\r\n\r\n  let modelDefinition = bindReplaceState(modelClone);\r\n  let mockedActions = [];\r\n\r\n  const persistKey = targetPath => `[${storeName}]@${targetPath.join('.')}`;\r\n  const persistor = createPersistor(persistKey, references);\r\n  const persistMiddleware = createPersistMiddleware(persistor, references);\r\n  const clearPersistance = createPersistenceClearer(persistKey, references);\r\n\r\n  const replaceState = nextState =>\r\n    references.internals.actionCreatorDict['@action.ePRS'](nextState);\r\n\r\n  const bindStoreInternals = (state = {}) => {\r\n    references.internals = createStoreInternals({\r\n      disableImmer,\r\n      initialState: state,\r\n      injections,\r\n      model: modelDefinition,\r\n      reducerEnhancer,\r\n      references,\r\n    });\r\n  };\r\n\r\n  const mockActionsMiddleware = () => () => action => {\r\n    if (action != null) {\r\n      mockedActions.push(action);\r\n    }\r\n    return undefined;\r\n  };\r\n\r\n  const composeEnhancers =\r\n    compose ||\r\n    (devTools &&\r\n    typeof window !== 'undefined' &&\r\n    window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\r\n      ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({\r\n          name: storeName,\r\n        })\r\n      : reduxCompose);\r\n\r\n  bindStoreInternals(initialState);\r\n\r\n  const easyPeasyMiddleware = [\r\n    createComputedPropertiesMiddleware(references),\r\n    reduxThunk,\r\n    ...middleware,\r\n    createListenerMiddleware(references),\r\n    persistMiddleware,\r\n  ];\r\n\r\n  if (mockActions) {\r\n    easyPeasyMiddleware.push(mockActionsMiddleware);\r\n  }\r\n\r\n  const store = reduxCreateStore(\r\n    references.internals.reducer,\r\n    references.internals.defaultState,\r\n    composeEnhancers(applyMiddleware(...easyPeasyMiddleware), ...enhancers),\r\n  );\r\n\r\n  store.subscribe(() => {\r\n    references.internals.computedState.isInReducer = false;\r\n  });\r\n\r\n  references.dispatch = store.dispatch;\r\n  references.getState = store.getState;\r\n\r\n  const bindActionCreators = () => {\r\n    Object.keys(store.dispatch).forEach(actionsKey => {\r\n      delete store.dispatch[actionsKey];\r\n    });\r\n    Object.keys(references.internals.actionCreators).forEach(key => {\r\n      store.dispatch[key] = references.internals.actionCreators[key];\r\n    });\r\n  };\r\n\r\n  bindActionCreators();\r\n\r\n  const rebindStore = removeKey => {\r\n    const currentState = store.getState();\r\n    if (removeKey) {\r\n      delete currentState[removeKey];\r\n    }\r\n    bindStoreInternals(currentState);\r\n    store.replaceReducer(references.internals.reducer);\r\n    replaceState(references.internals.defaultState);\r\n    bindActionCreators();\r\n  };\r\n\r\n  const resolveRehydration = rehydrateStateFromPersistIfNeeded(\r\n    persistKey,\r\n    replaceState,\r\n    references,\r\n  );\r\n\r\n  return Object.assign(store, {\r\n    addModel: (key, modelForKey) => {\r\n      if (modelDefinition[key] && process.env.NODE_ENV !== 'production') {\r\n        // eslint-disable-next-line no-console\r\n        console.warn(\r\n          `easy-peasy: The store model already contains a model definition for \"${key}\"`,\r\n        );\r\n        store.removeModel(key);\r\n      }\r\n      modelDefinition[key] = modelForKey;\r\n      rebindStore();\r\n    },\r\n    clearMockedActions: () => {\r\n      mockedActions = [];\r\n    },\r\n    getActions: () => references.internals.actionCreators,\r\n    getListeners: () => references.internals.listenerActionCreators,\r\n    getMockedActions: () => [...mockedActions],\r\n    persist: {\r\n      clear: clearPersistance,\r\n      flush: () => persistor.flush(),\r\n      resolveRehydration: () => resolveRehydration,\r\n    },\r\n    reconfigure: newModel => {\r\n      modelDefinition = bindReplaceState(newModel);\r\n      rebindStore();\r\n    },\r\n    removeModel: key => {\r\n      if (!modelDefinition[key]) {\r\n        if (process.env.NODE_ENV !== 'production') {\r\n          // eslint-disable-next-line no-console\r\n          console.warn(\r\n            `easy-peasy: The store model does not contain a model definition for \"${key}\"`,\r\n          );\r\n        }\r\n        return;\r\n      }\r\n      delete modelDefinition[key];\r\n      rebindStore(key);\r\n    },\r\n  });\r\n}\r\n","import createReducer from './create-reducer';\r\nimport extractDataFromModel from './extract-data-from-model';\r\n\r\nexport default function createStoreInternals({\r\n  disableImmer,\r\n  initialState,\r\n  injections,\r\n  model,\r\n  reducerEnhancer,\r\n  references,\r\n}) {\r\n  const {\r\n    actionCreatorDict,\r\n    actionCreators,\r\n    actionReducersDict,\r\n    computedState,\r\n    computedProperties,\r\n    customReducers,\r\n    defaultState,\r\n    listenerActionCreators,\r\n    listenerActionMap,\r\n    persistenceConfig,\r\n  } = extractDataFromModel(model, initialState, injections, references);\r\n\r\n  const rootReducer = createReducer(\r\n    disableImmer,\r\n    actionReducersDict,\r\n    customReducers,\r\n    computedProperties,\r\n  );\r\n\r\n  return {\r\n    actionCreatorDict,\r\n    actionCreators,\r\n    computedProperties,\r\n    computedState,\r\n    defaultState,\r\n    listenerActionCreators,\r\n    listenerActionMap,\r\n    persistenceConfig,\r\n    reducer: reducerEnhancer(rootReducer),\r\n  };\r\n}\r\n","import { setAutoFreeze } from 'immer-peasy';\r\nimport {\r\n  createTypedHooks,\r\n  useStoreActions,\r\n  useStoreDispatch,\r\n  useStoreState,\r\n  useStoreRehydrated,\r\n  useStore,\r\n} from './hooks';\r\nimport createStore from './create-store';\r\nimport createContextStore from './create-context-store';\r\nimport createComponentStore from './create-component-store';\r\nimport createTransform from './create-transform';\r\nimport StoreProvider from './provider';\r\nimport {\r\n  action,\r\n  actionOn,\r\n  computed,\r\n  debug,\r\n  memo,\r\n  persist,\r\n  reducer,\r\n  thunk,\r\n  thunkOn,\r\n} from './helpers';\r\n\r\n/**\r\n * The auto freeze feature of immer doesn't seem to work in our testing. We have\r\n * explicitly disabled it to avoid perf issues.\r\n */\r\nsetAutoFreeze(false);\r\n\r\nexport {\r\n  action,\r\n  actionOn,\r\n  computed,\r\n  createComponentStore,\r\n  createContextStore,\r\n  createStore,\r\n  createTransform,\r\n  createTypedHooks,\r\n  debug,\r\n  memo,\r\n  persist,\r\n  reducer,\r\n  StoreProvider,\r\n  thunk,\r\n  thunkOn,\r\n  useStoreActions,\r\n  useStoreDispatch,\r\n  useStoreState,\r\n  useStoreRehydrated,\r\n  useStore,\r\n};\r\n","import React from 'react';\r\nimport StoreContext from './context';\r\n\r\nexport default function StoreProvider({ children, store }) {\r\n  return (\r\n    <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\r\n  );\r\n}\r\n","import { useMemo, useState, useRef, useEffect } from 'react';\r\nimport createStore from './create-store';\r\n\r\n/**\r\n * Some good references on the topic of reinitialisation:\r\n * - https://github.com/facebook/react/issues/14830\r\n */\r\n\r\nexport default function createComponentStore(model, config) {\r\n  return function useLocalStore(initialData) {\r\n    const store = useMemo(\r\n      () =>\r\n        createStore(\r\n          typeof model === 'function' ? model(initialData) : model,\r\n          config,\r\n        ),\r\n      [],\r\n    );\r\n    const previousStateRef = useRef(store.getState());\r\n    const [currentState, setCurrentState] = useState(() => store.getState());\r\n    useEffect(() => {\r\n      return store.subscribe(() => {\r\n        const nextState = store.getState();\r\n        if (previousStateRef.current !== nextState) {\r\n          previousStateRef.current = nextState;\r\n          setCurrentState(nextState);\r\n        }\r\n      });\r\n    }, [store]);\r\n    return [currentState, store.getActions()];\r\n  };\r\n}\r\n","/* eslint-disable react/prop-types */\r\n\r\nimport React, { createContext, useContext, useMemo } from 'react';\r\nimport {\r\n  createStoreActionsHook,\r\n  createStoreDispatchHook,\r\n  createStoreStateHook,\r\n  createStoreRehydratedHook,\r\n} from './hooks';\r\nimport createStore from './create-store';\r\n\r\nexport default function createContextStore(model, config) {\r\n  const StoreContext = createContext();\r\n\r\n  function Provider({ children, initialData }) {\r\n    const store = useMemo(\r\n      () =>\r\n        createStore(\r\n          typeof model === 'function' ? model(initialData) : model,\r\n          config,\r\n        ),\r\n      [],\r\n    );\r\n    return (\r\n      <StoreContext.Provider value={store}>{children}</StoreContext.Provider>\r\n    );\r\n  }\r\n\r\n  function useStore() {\r\n    return useContext(StoreContext);\r\n  }\r\n\r\n  return {\r\n    Provider,\r\n    useStore,\r\n    useStoreState: createStoreStateHook(StoreContext),\r\n    useStoreActions: createStoreActionsHook(StoreContext),\r\n    useStoreDispatch: createStoreDispatchHook(StoreContext),\r\n    useStoreRehydrated: createStoreRehydratedHook(StoreContext),\r\n  };\r\n}\r\n","/**\r\n * This file has been copied from redux-persist.\r\n * The intention being to support as much of the redux-persist API as possible.\r\n */\r\n\r\nexport default function createTransform(inbound, outbound, config = {}) {\r\n  const whitelist = config.whitelist || null;\r\n  const blacklist = config.blacklist || null;\r\n\r\n  function whitelistBlacklistCheck(key) {\r\n    if (whitelist && whitelist.indexOf(key) === -1) return true;\r\n    if (blacklist && blacklist.indexOf(key) !== -1) return true;\r\n    return false;\r\n  }\r\n\r\n  return {\r\n    in: (data, key, fullState) =>\r\n      !whitelistBlacklistCheck(key) && inbound\r\n        ? inbound(data, key, fullState)\r\n        : data,\r\n    out: (data, key, fullState) =>\r\n      !whitelistBlacklistCheck(key) && outbound\r\n        ? outbound(data, key, fullState)\r\n        : data,\r\n  };\r\n}\r\n"],"names":["StoreContext","createContext","useIsomorphicLayoutEffect","window","useLayoutEffect","useEffect","createStoreStateHook","Context","mapState","store","useContext","mapStateRef","useRef","stateRef","mountedRef","subscriptionMapStateError","forceRender","useReducer","s","current","undefined","getState","err","checkMapState","newState","unsubscribe","subscribe","useStoreState","EasyPeasyContext","createStoreActionsHook","mapActions","getActions","useStoreActions","createStoreDispatchHook","dispatch","useStoreDispatch","useStore","createStoreRehydratedHook","useState","rehydrated","setRehydrated","persist","resolveRehydration","then","useStoreRehydrated","actionSymbol","actionOnSymbol","computedSymbol","persistSymbol","reducerSymbol","thunkOnSymbol","thunkSymbol","action","fn","defaultStateResolvers","state","deepCloneStateWithoutComputed","source","recursiveClone","next","Object","keys","reduce","acc","key","getOwnPropertyDescriptor","get","forEach","isPlainObject","isPromise","x","path","target","cur","set","value","length","idx","createSimpleProduce","disableImmer","newify","currentPath","currentState","finalValue","slice","draft","createDraft","result","isDraft","finishDraft","parentPath","parent","createReducer","actionReducersDict","customReducers","computedProperties","reducerForActions","actionReducer","type","actionMeta","simpleProduce","payload","stateAfterActions","red","reducer","bindComputedProperty","noopStorage","getItem","setItem","removeItem","localStorage","sessionStorage","createStorageWrapper","storage","transformers","deserialize","data","simpleKey","substr","indexOf","JSON","parse","outTransformers","out","reverse","isAsync","wrapped","transformed","in","stringify","resolvePersistTargets","whitelist","blacklist","targets","findIndex","rehydrateStateFromPersistIfNeeded","persistKey","replaceState","references","Promise","resolve","internals","persistenceConfig","persistInstance","applyRehydrationStrategy","originalState","rehydratedState","mergeStrategy","setAt","currentTarget","currentNext","config","defaultState","asyncStateResolvers","targetPath","dataPromise","push","all","map","resolvedData","createActionCreator","actionDefinition","meta","join","actionName","actionCreator","resolvedTargets","createThunkActionsCreator","thunkDefinition","thunkHandler","startType","successType","failType","thunkMeta","dispatchError","error","dispatchSuccess","resolved","catch","extractDataFromModel","model","initialState","injections","actionCreators","actionCreatorDict","listenerActionMap","actionThunks","listenerActionCreators","listenerDefinitions","computedState","isInReducer","recursiveExtractFromModel","handleValueAsState","initialParentRef","persistDefinition","definition","computedMeta","memoisedResultFn","helpers","getStoreActions","getStoreState","memoizerific","o","defineProperty","configurable","enumerable","storeState","inputs","stateResolvers","resolver","listenerActionOrThunk","listenerMeta","targetResolver","targetTypes","Array","isArray","targetType","listenerReg","createStore","options","bindReplaceState","modelDef","ePRS","_","storeName","nextState","bindStoreInternals","reducerEnhancer","modelDefinition","persistor","modelClone","compose","devTools","enhancers","middleware","mockActions","name","rootReducer","mockedActions","debounce","persistMiddleware","clearPersistance","reject","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","reduxCompose","easyPeasyMiddleware","reduxThunk","sourceAction","reduxCreateStore","applyMiddleware","bindActionCreators","actionsKey","rebindStore","removeKey","replaceReducer","assign","addModel","modelForKey","clearMockedActions","getListeners","getMockedActions","clear","flush","reconfigure","newModel","removeModel","children","React","Provider","fnOrStateResolvers","initialData","useMemo","previousStateRef","setCurrentState","inbound","outbound","whitelistBlacklistCheck","fullState","original","cacheSize"],"mappings":"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"}